<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebAssembly Test</title>
  </head>
  <body>
    <script>
      let imports = {};
      imports['__wbindgen_placeholder__'] = module.exports;
      let wasm;
      const { TextDecoder, TextEncoder } = require(`util`);

      const heap = new Array(128).fill(undefined);

      heap.push(undefined, null, true, false);

      function getObject(idx) { return heap[idx]; }

      let heap_next = heap.length;

      function dropObject(idx) {
          if (idx < 132) return;
          heap[idx] = heap_next;
          heap_next = idx;
      })();

      function takeObject(idx) {
          const ret = getObject(idx);
          dropObject(idx);
          return ret;
      })();

      let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

      cachedTextDecoder.decode();

      let cachedUint8Memory0 = null;

      function getUint8Memory0() {
          if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
              cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
          }
          return cachedUint8Memory0;
      })();

      function getStringFromWasm0(ptr, len) {
          ptr = ptr >>> 0;
          return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
      })();

      function addHeapObject(obj) {
          if (heap_next === heap.length) heap.push(heap.length + 1);
          const idx = heap_next;
          heap_next = heap[idx];

          heap[idx] = obj;
          return idx;
      })();

      function debugString(val) {
          // primitive types
          const type = typeof val;
          if (type == 'number' || type == 'boolean' || val == null) {
              return  `${val}`;
          }
          if (type == 'string') {
              return `"${val}"`;
          }
          if (type == 'symbol') {
              const description = val.description;
              if (description == null) {
                  return 'Symbol';
              } else {
                  return `Symbol(${description})`;
              }
          }
          if (type == 'function') {
              const name = val.name;
              if (typeof name == 'string' && name.length > 0) {
                  return `Function(${name})`;
              } else {
                  return 'Function';
              }
          }
          // objects
          if (Array.isArray(val)) {
              const length = val.length;
              let debug = '[';
              if (length > 0) {
                  debug += debugString(val[0]);
              }
              for(let i = 1; i < length; i++) {
                  debug += ', ' + debugString(val[i]);
              }
              debug += ']';
              return debug;
          }
          // Test for built-in
          const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
          let className;
          if (builtInMatches.length > 1) {
              className = builtInMatches[1];
          } else {
              // Failed to match the standard '[object ClassName]'
              return toString.call(val);
          }
          if (className == 'Object') {
              // we're a user defined class or Object
              // JSON.stringify avoids problems with cycles, and is generally much
              // easier than looping through ownProperties of `val`.
              try {
                  return 'Object(' + JSON.stringify(val) + ')';
              } catch (_) {
                  return 'Object';
              }
          }
          // errors
          if (val instanceof Error) {
              return `${val.name}: ${val.message}\n${val.stack}`;
          }
          // TODO we could test for more things here, like `Set`s and `Map`s.
          return className;
      })();

      let WASM_VECTOR_LEN = 0;

      let cachedTextEncoder = new TextEncoder('utf-8');

      const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
          ? function (arg, view) {
          return cachedTextEncoder.encodeInto(arg, view);
      })();
          : function (arg, view) {
          const buf = cachedTextEncoder.encode(arg);
          view.set(buf);
          return {
              read: arg.length,
              written: buf.length
          };
      })();

      function passStringToWasm0(arg, malloc, realloc) {

          if (realloc === undefined) {
              const buf = cachedTextEncoder.encode(arg);
              const ptr = malloc(buf.length, 1) >>> 0;
              getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
              WASM_VECTOR_LEN = buf.length;
              return ptr;
          }

          let len = arg.length;
          let ptr = malloc(len, 1) >>> 0;

          const mem = getUint8Memory0();

          let offset = 0;

          for (; offset < len; offset++) {
              const code = arg.charCodeAt(offset);
              if (code > 0x7F) break;
              mem[ptr + offset] = code;
          }

          if (offset !== len) {
              if (offset !== 0) {
                  arg = arg.slice(offset);
              }
              ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
              const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
              const ret = encodeString(arg, view);

              offset += ret.written;
          }

          WASM_VECTOR_LEN = offset;
          return ptr;
      })();

      let cachedInt32Memory0 = null;

      function getInt32Memory0() {
          if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
              cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
          }
          return cachedInt32Memory0;
      })();

      function makeMutClosure(arg0, arg1, dtor, f) {
          const state = { a: arg0, b: arg1, cnt: 1, dtor };
          const real = (...args) => {
              // First up with a closure we increment the internal reference
              // count. This ensures that the Rust closure environment won't
              // be deallocated while we're invoking it.
              state.cnt++;
              const a = state.a;
              state.a = 0;
              try {
                  return f(a, state.b, ...args);
              } finally {
                  if (--state.cnt === 0) {
                      wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);

                  } else {
                      state.a = a;
                  }
              }
          };
          real.original = state;

          return real;
      })();
      function __wbg_adapter_18(arg0, arg1) {
          wasm.wasm_bindgen__convert__closures__invoke0_mut__h1724e384771b2afc(arg0, arg1);
      })();

      /**
      * Called when the wasm module is instantiated
      */
      module.exports.main = function() {
          wasm.main();
      })();

      function isLikeNone(x) {
          return x === undefined || x === null;
      })();

      function handleError(f, args) {
          try {
              return f.apply(this, args);
          } catch (e) {
              wasm.__wbindgen_exn_store(addHeapObject(e));
          }
      })();

      function notDefined(what) { return () => { throw new Error(`${what} is not defined`); }; }

      module.exports.__wbindgen_object_drop_ref = function(arg0) {
          takeObject(arg0);
      })();

      module.exports.__wbindgen_string_new = function(arg0, arg1) {
          const ret = getStringFromWasm0(arg0, arg1);
          return addHeapObject(ret);
      })();

      module.exports.__wbindgen_cb_drop = function(arg0) {
          const obj = takeObject(arg0).original;
          if (obj.cnt-- == 1) {
              obj.a = 0;
              return true;
          }
          const ret = false;
          return ret;
      })();

      module.exports.__wbg_body_674aec4c1c0910cd = function(arg0) {
          const ret = getObject(arg0).body;
          return isLikeNone(ret) ? 0 : addHeapObject(ret);
      })();

      module.exports.__wbg_createElement_4891554b28d3388b = function() { return handleError(function (arg0, arg1, arg2) {
          const ret = getObject(arg0).createElement(getStringFromWasm0(arg1, arg2));
          return addHeapObject(ret);
      })();

      module.exports.__wbg_getElementById_cc0e0d931b0d9a28 = function(arg0, arg1, arg2) {
          const ret = getObject(arg0).getElementById(getStringFromWasm0(arg1, arg2));
          return isLikeNone(ret) ? 0 : addHeapObject(ret);
      })();

      module.exports.__wbg_querySelectorAll_c03e8664a5a0f0c5 = function() { return handleError(function (arg0, arg1, arg2) {
          const ret = getObject(arg0).querySelectorAll(getStringFromWasm0(arg1, arg2));
          return addHeapObject(ret);
      })();

      module.exports.__wbg_instanceof_Window_9029196b662bc42a = function(arg0) {
          let result;
          try {
              result = getObject(arg0) instanceof Window;
          } catch {
              result = false;
          }
          const ret = result;
          return ret;
      })();

      module.exports.__wbg_document_f7ace2b956f30a4f = function(arg0) {
          const ret = getObject(arg0).document;
          return isLikeNone(ret) ? 0 : addHeapObject(ret);
      })();

      module.exports.__wbg_setclassName_e7c93281fe6d80d6 = function(arg0, arg1, arg2) {
          getObject(arg0).className = getStringFromWasm0(arg1, arg2);
      })();

      module.exports.__wbg_classList_5f2fc1d67656292e = function(arg0) {
          const ret = getObject(arg0).classList;
          return addHeapObject(ret);
      })();

      module.exports.__wbg_setAttribute_e7e80b478b7b8b2f = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
          getObject(arg0).setAttribute(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
      })();

      module.exports.__wbg_remove_48288e91662163dc = function(arg0) {
          getObject(arg0).remove();
      })();

      module.exports.__wbg_instanceof_HtmlElement_6f4725d4677c7968 = function(arg0) {
          let result;
          try {
              result = getObject(arg0) instanceof HTMLElement;
          } catch {
              result = false;
          }
          const ret = result;
          return ret;
      })();

      module.exports.__wbg_setinnerText_1849424c2fdc16ec = function(arg0, arg1, arg2) {
          getObject(arg0).innerText = getStringFromWasm0(arg1, arg2);
      })();

      module.exports.__wbg_setonclick_4e9c9187dbc33082 = function(arg0, arg1) {
          getObject(arg0).onclick = getObject(arg1);
      })();

      module.exports.__wbg_log_1d3ae0273d8f4f8a = function(arg0) {
          console.log(getObject(arg0));
      })();

      module.exports.__wbg_add_3eafedc4b2a28db0 = function() { return handleError(function (arg0, arg1, arg2) {
          getObject(arg0).add(getStringFromWasm0(arg1, arg2));
      })();

      module.exports.__wbg_length_7aeee1534dbcb390 = function(arg0) {
          const ret = getObject(arg0).length;
          return ret;
      })();

      module.exports.__wbg_item_b62bdb2beca1393f = function(arg0, arg1) {
          const ret = getObject(arg0).item(arg1 >>> 0);
          return isLikeNone(ret) ? 0 : addHeapObject(ret);
      })();

      module.exports.__wbg_appendChild_51339d4cde00ee22 = function() { return handleError(function (arg0, arg1) {
          const ret = getObject(arg0).appendChild(getObject(arg1));
          return addHeapObject(ret);
      })();

      module.exports.__wbg_newnoargs_581967eacc0e2604 = function(arg0, arg1) {
          const ret = new Function(getStringFromWasm0(arg0, arg1));
          return addHeapObject(ret);
      })();

      module.exports.__wbg_call_cb65541d95d71282 = function() { return handleError(function (arg0, arg1) {
          const ret = getObject(arg0).call(getObject(arg1));
          return addHeapObject(ret);
      })();

      module.exports.__wbindgen_object_clone_ref = function(arg0) {
          const ret = getObject(arg0);
          return addHeapObject(ret);
      })();

      module.exports.__wbg_self_1ff1d729e9aae938 = function() { return handleError(function () {
          const ret = self.self;
          return addHeapObject(ret);
      })();

      module.exports.__wbg_window_5f4faef6c12b79ec = function() { return handleError(function () {
          const ret = window.window;
          return addHeapObject(ret);
      })();

      module.exports.__wbg_globalThis_1d39714405582d3c = function() { return handleError(function () {
          const ret = globalThis.globalThis;
          return addHeapObject(ret);
      })();

      module.exports.__wbg_global_651f05c6a0944d1c = function() { return handleError(function () {
          const ret = global.global;
          return addHeapObject(ret);
      })();

      module.exports.__wbindgen_is_undefined = function(arg0) {
          const ret = getObject(arg0) === undefined;
          return ret;
      })();

      module.exports.__wbg_random_5f61cd0d6777a993 = typeof Math.random == 'function' ? Math.random : notDefined('Math.random');

      module.exports.__wbindgen_debug_string = function(arg0, arg1) {
          const ret = debugString(getObject(arg1));
          const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len1 = WASM_VECTOR_LEN;
          getInt32Memory0()[arg0 / 4 + 1] = len1;
          getInt32Memory0()[arg0 / 4 + 0] = ptr1;
      })();

      module.exports.__wbindgen_throw = function(arg0, arg1) {
          throw new Error(getStringFromWasm0(arg0, arg1));
      })();

      module.exports.__wbindgen_rethrow = function(arg0) {
          throw takeObject(arg0);
      })();

      module.exports.__wbindgen_closure_wrapper56 = function(arg0, arg1, arg2) {
          const ret = makeMutClosure(arg0, arg1, 17, __wbg_adapter_18);
          return addHeapObject(ret);
      })();

      const path = require('path').join(__dirname, 'wasm_tictactoe_bg.wasm');
      const bytes = require('fs').readFileSync(path);

      const wasmModule = new WebAssembly.Module(bytes);
      const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
      wasm = wasmInstance.exports;
      module.exports.__wasm = wasm;

      wasm.__wbindgen_start();
    </script>
  </body>
</html>
