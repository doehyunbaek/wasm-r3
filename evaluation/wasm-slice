#!/usr/bin/env python3

import sys, subprocess, os, csv, subprocess, shutil
import evaluation

# this takes upto 150GB of memory.
# TODO: why?
WASMR3_PATH = os.getenv("WASMR3_PATH", "/home/wasm-r3")
PARALLEL = os.getenv
TIMEOUT = 120

# The Wasm file is given as the first and only argument to the script.
if len(sys.argv) != 3:
    print("Usage: wasm-slice <WASM_FILE> <ORACLE_SCRIPT>")
    sys.exit(1)

interesting_script = sys.argv[1]
test_input = sys.argv[2]
test_name = os.path.splitext(os.path.basename(test_input))[0]

# We prioritize single function replay of heuristic > dynamic > all

def get_heuristic_fidx() -> list:
    # Hardcode for now
    # TODO: implement heuristics
    testname_to_heuristic = {
        "commanderkeen": [490],
        "funky-kart": [1529],
        "guiicons": [213],
        "hydro": [1290],
        "jsc": [4771],
        "mandelbrot": [7],
        "rfxgen": [271],
        "rguilayout": [216],
        "rguistyler": [260],
        "riconpacker": [244],
        "rtexviewer": [303],
        "sqlgui": [917],
        "wasmedge#3018": [8, 11],
        "wasmedge#3019": [5, 6, 75],
        "wasmedge#3057": [951, 952, 969, 970, 973, 1003, 1005]
    }
    if testname_to_heuristic.get(test_name):
        return testname_to_heuristic[test_name]
    else:
        print("WARNING: No heuristic set found for", test_name)
        return []

def extract_dynamic_fidx(csv_output: str):
    dynamic_fidx = []
    reader = csv.reader(csv_output.splitlines())
    next(reader)  # Skip header
    for row in reader:
        if len(row) >= 3:
            function_index = int(row[0].lstrip('#'))
            dynamic_count = int(row[2])
            if dynamic_count > 0 and function_index != 0:
                dynamic_fidx.append(function_index)
    return sorted(dynamic_fidx)

def get_dynamic_fidx():
    command = ["wizeng.x86-64-linux", "-no-names", "-csv", "--monitors=icount", test_input]
    try:
        return extract_dynamic_fidx(subprocess.check_output(command, text=True))
    except subprocess.CalledProcessError as e:
        print(f"WARNING: No dynamic set found for {test_name}")
        exit(1)
        return []


def get_fidx():
    heuristic_fidx = get_heuristic_fidx()
    dynamic_fidx = get_dynamic_fidx()
    all_fidx = evaluation.get_all_fidx(test_input)

    print("Heuristic function indices:", heuristic_fidx)
    dynamic_filtered = [idx for idx in dynamic_fidx if idx not in heuristic_fidx]
    print("Dynamic function indices (except heuristic):", dynamic_filtered)

    # Filter out both heuristic and dynamic indices from all
    all_filtered = [idx for idx in all_fidx if idx not in heuristic_fidx and idx not in dynamic_fidx]
    print("All function indices (except heuristic and dynamic):", all_filtered)

    # Create a set to keep track of added indices
    added = set()
    combined_fidx = []

    # Add heuristic_fidx first
    for idx in heuristic_fidx:
        if idx not in added:
            combined_fidx.append(idx)
            added.add(idx)

    # Add dynamic_fidx second
    for idx in dynamic_fidx:
        if idx not in added:
            combined_fidx.append(idx)
            added.add(idx)

    # Add all_fidx last
    for idx in all_fidx:
        if idx not in added:
            combined_fidx.append(idx)
            added.add(idx)

    return combined_fidx


def run_slicedice(testname, fidx):
    try:
        # fidxargs = " ".join([f"-i {f}" for f in fidx.split("-")])
        command = f"timeout {TIMEOUT}s npm test slicedice -- -t {testname} -i {fidx}"
        output = subprocess.check_output(command, shell=True, text=True)
        # TODO: make this configurable
        replay_wasm_path = f'{WASMR3_PATH}/benchmarks/{test_name}/out/{fidx}/benchmarks/bin_1/replay.wasm'
        shutil.copy(replay_wasm_path, f'{WASMR3_PATH}/benchmarks/{test_name}/{test_name}.sliced.wasm')
        interestingness_command = [interesting_script, replay_wasm_path]
        result = subprocess.run(interestingness_command, check=False)
        test_input_size = os.path.getsize(test_input)
        replay_wasm_size = os.path.getsize(replay_wasm_path)
        print("Test input file size:", test_input_size)
        print("Sliced wasm file size:", replay_wasm_size)
        sys.exit(result.returncode)
    except Exception as e:
        print(f"Failed to run {testname} - {fidx}")
        print(e)
        return [testname, fidx, "fail"]

for fidx in get_fidx():
    run_slicedice(test_name, fidx)